<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nexus AI - Interface</title>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes pulseOpacity { 0%, 100% { opacity: 0.4; } 50% { opacity: 0.7; } }

    .animate-fadeIn { animation: fadeIn 0.4s ease-out forwards; }
    .animate-pulse-soft { animation: pulseOpacity 2s infinite ease-in-out; }

    body, html, #root { height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #000; }

    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 10px; }

    .prose { color: #e5e7eb; font-size: 0.95rem; line-height: 1.6; }
    .prose strong { color: #fff; }
    .prose h1, .prose h2 { color: #fff; margin-top: 1em; margin-bottom: 0.5em; font-weight: 700; }
    .prose code { background: rgba(255,255,255,0.1); padding: 0.2em 0.4em; border-radius: 0.3em; }
    .prose pre { background: rgba(0,0,0,0.3); padding: 1em; border-radius: 0.5em; overflow-x: auto; }

    .ai-thought {
      font-style: italic;
      opacity: 0.6;
      font-size: 0.85rem;
      border-left: 2px solid rgba(255,255,255,0.2);
      padding-left: 1rem;
      margin-bottom: 1rem;
      color: #9ca3af;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    /*************************
     * CONFIG / CONSTANTES
     *************************/
    const N8N_TEXT_WEBHOOK =
      "https://esmieunathan.app.n8n.cloud/webhook/e19ae4b2-a192-4512-9e5f-b03d0580be78";

    const N8N_FILE_WEBHOOK =
      "https://esmieunathan.app.n8n.cloud/webhook/2131cbf7-62e1-4e92-86a7-69a51cd1ad3b";

    const THOUGHT_STEPS = [
      "Analyse de la demande",
      "Consultation de la base de données",
      "Traitement des informations",
      "Synthèse des résultats",
      "Finalisation de la réponse"
    ];

    const DEFAULT_CONFIG = {
      companyName: "Nexus AI",
      primaryColor: "#6366f1",
    };

    /*************************
     * UTILS (SAFE)
     *************************/
    const uid = () => {
      try { return crypto.randomUUID(); }
      catch { return String(Date.now() + Math.random()); }
    };

    const safeJsonParse = (text) => {
      try { return JSON.parse(text); } catch { return text; }
    };

    const normalizeWebhookResponseToText = (data) => {
      if (data == null) return "Réponse vide.";
      if (typeof data === "string") return data;

      if (Array.isArray(data) && data.length > 0) {
        const first = data[0];
        if (typeof first === "string") return first;
        if (first && typeof first === "object") {
          return (
            first.output ||
            first.reply ||
            first.data ||
            first.text ||
            Object.values(first)[0] ||
            JSON.stringify(first)
          );
        }
        return JSON.stringify(first);
      }

      if (typeof data === "object") {
        return (
          data.output ||
          data.reply ||
          data.data ||
          data.text ||
          Object.values(data)[0] ||
          JSON.stringify(data)
        );
      }

      return String(data);
    };

    // ✅ Fetch safe: protège contre réponse énorme + parsing safe
    const fetchWebhook = async (url, options) => {
      const res = await fetch(url, options);
      const raw = await res.text();
      const safeRaw = raw.length > 2_000_000 ? raw.slice(0, 2_000_000) : raw;
      const parsed = safeJsonParse(safeRaw);
      return { ok: res.ok, status: res.status, data: parsed };
    };

    const sendFileToWebhook = async ({ file, sessionId, source, chatHistory }) => {
      const fd = new FormData();
      fd.append("file", file, file.name);
      fd.append("fileName", file.name);
      fd.append("mimeType", file.type || "");
      fd.append("sessionId", String(sessionId));
      fd.append("source", source); // "sidebar" | "chat"
      if (chatHistory) fd.append("chatHistory", JSON.stringify(chatHistory));

      const { ok, status, data } = await fetchWebhook(N8N_FILE_WEBHOOK, {
        method: "POST",
        body: fd
      });

      if (!ok) {
        const msg = typeof data === "string" ? data : JSON.stringify(data);
        throw new Error(`Upload refusé (${status}) : ${msg}`);
      }

      return normalizeWebhookResponseToText(data);
    };

    /*************************
     * ✅ Hook desktop fiable (innerWidth) à la place de matchMedia
     *************************/
    const useIsDesktop = () => {
      const get = () => (typeof window !== "undefined" ? window.innerWidth >= 768 : true);
      const [isDesktop, setIsDesktop] = useState(get);

      useEffect(() => {
        const onResize = () => setIsDesktop(window.innerWidth >= 768);
        window.addEventListener("resize", onResize);
        return () => window.removeEventListener("resize", onResize);
      }, []);

      return isDesktop;
    };

    /*************************
     * UI COMPONENTS (SAFE)
     *************************/
    const Icon = ({ name, size = 20, className = "" }) => {
      useEffect(() => {
        try {
          if (window.lucide && typeof window.lucide.createIcons === "function") {
            window.lucide.createIcons();
          }
        } catch (_) {}
      }, [name]);

      return (
        <i
          data-lucide={name}
          className={className}
          style={{
            width: size,
            height: size,
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
          }}
        />
      );
    };

    // ✅ Marked safe: si marked indisponible => fallback HTML safe
    const safeMarkedParse = (md) => {
      try {
        if (window.marked && typeof window.marked.parse === "function") {
          return window.marked.parse(md || "");
        }
      } catch (_) {}

      const esc = (s) =>
        String(s || "").replace(/[&<>"']/g, (c) => ({
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          "\"": "&quot;",
          "'": "&#39;",
        }[c]));

      return `<p>${esc(md || "")}</p>`;
    };

    const MessageContent = ({ content }) => {
      const raw = String(content || "");
      const thinkingMatch = raw.match(/<thinking>([\s\S]*?)<\/thinking>/);
      const thinking = thinkingMatch ? thinkingMatch[1] : null;
      const mainContent = raw.replace(/<thinking>[\s\S]*?<\/thinking>/, "").trim();

      return (
        <div className="prose">
          {thinking && (
            <div className="ai-thought flex flex-col gap-1">
              <span className="text-[10px] uppercase tracking-widest font-bold opacity-50 flex items-center gap-2">
                <Icon name="brain" size={10} /> Réflexion
              </span>
              <div dangerouslySetInnerHTML={{ __html: safeMarkedParse(thinking) }} />
            </div>
          )}
          <div dangerouslySetInnerHTML={{ __html: safeMarkedParse(mainContent) }} />
        </div>
      );
    };

    const FileBubble = ({ m }) => {
      const isImage = (m.mimeType || "").startsWith("image/");
      return (
        <div className="flex flex-col gap-3">
          {isImage && m.previewUrl && (
            <img
              src={m.previewUrl}
              alt={m.fileName}
              className="w-full max-w-[420px] rounded-2xl border border-white/10 shadow-lg"
            />
          )}

          <div className="flex items-center gap-3 min-w-0">
            <div className="p-2 rounded-xl bg-white/5 border border-white/10 shrink-0">
              <Icon name={isImage ? "image" : "file-text"} size={18} className="opacity-80" />
            </div>

            <div className="min-w-0 flex-1">
              <div className="text-sm font-medium truncate">{m.fileName}</div>
              <div className="text-xs opacity-60 flex items-center gap-2">
                {m.status === "uploading" && (
                  <>
                    <Icon name="loader-2" size={14} className="animate-spin" />
                    <span>Envoi en attente de validation…</span>
                  </>
                )}
                {m.status === "sent" && (
                  <>
                    <Icon name="check-circle-2" size={14} />
                    <span>Envoyé</span>
                  </>
                )}
                {m.status === "error" && (
                  <>
                    <Icon name="x-circle" size={14} />
                    <span>Échec</span>
                  </>
                )}
              </div>
              {m.error && m.status === "error" && (
                <div className="text-xs text-red-400 mt-1 break-words">{m.error}</div>
              )}
            </div>
          </div>
        </div>
      );
    };

    /*************************
     * NEURAL GLOW (inchangé)
     *************************/
    const NeuralGlow = ({ color, mouseTracking }) => {
      const canvasRef = useRef(null);

      const glRef = useRef(null);
      const programRef = useRef(null);
      const uniformsRef = useRef(null);
      const rafRef = useRef(null);

      const pointerRef = useRef({ x: 0, y: 0, tX: 0, tY: 0 });
      const colorRef = useRef(color);
      const mouseTrackingRef = useRef(mouseTracking);

      useEffect(() => { colorRef.current = color; }, [color]);
      useEffect(() => { mouseTrackingRef.current = mouseTracking; }, [mouseTracking]);

      const hexToRgb = (hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
          ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255]
          : [0.1, 0.2, 0.8];
      };

      const vertexShaderSource = `
        precision mediump float;
        varying vec2 vUv;
        attribute vec2 a_position;
        void main() {
          vUv = .5 * (a_position + 1.);
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      const fragmentShaderSource = `
        precision mediump float;
        varying vec2 vUv;
        uniform float u_time;
        uniform float u_ratio;
        uniform vec2 u_pointer_position;
        uniform float u_scroll_progress;
        uniform vec3 u_base_color;

        vec2 rotate(vec2 uv, float th) {
          return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
        }

        float neuro_shape(vec2 uv, float t, float p) {
          vec2 sine_acc = vec2(0.);
          vec2 res = vec2(0.);
          float scale = 8.;
          for (int j = 0; j < 15; j++) {
            uv = rotate(uv, 1.);
            sine_acc = rotate(sine_acc, 1.);
            vec2 layer = uv * scale + float(j) + sine_acc - t;
            sine_acc += sin(layer) + 2.4 * p;
            res += (.5 + .5 * cos(layer)) / scale;
            scale *= (1.2);
          }
          return res.x + res.y;
        }

        void main() {
          vec2 uv = .5 * vUv;
          uv.x *= u_ratio;
          vec2 pointer = vUv - u_pointer_position;
          pointer.x *= u_ratio;
          float p = clamp(length(pointer), 0., 1.);
          p = .5 * pow(1. - p, 2.);
          float t = .001 * u_time;
          float noise = neuro_shape(uv, t, p);
          noise = 1.2 * pow(noise, 3.);
          noise += pow(noise, 10.);
          noise = max(.0, noise - .5);
          noise *= (1. - length(vUv - .5));
          vec3 color = u_base_color;
          color += (u_base_color * 0.5) * sin(3.0 * u_scroll_progress + 1.5);
          gl_FragColor = vec4(color * noise, noise);
        }
      `;

      const initGL = () => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        if (!gl) return;

        glRef.current = gl;

        const createShader = (type, src) => {
          const s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          return s;
        };

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vertexShaderSource));
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fragmentShaderSource));
        gl.linkProgram(program);
        gl.useProgram(program);

        programRef.current = program;

        const uniforms = {};
        const count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < count; i++) {
          const info = gl.getActiveUniform(program, i);
          uniforms[info.name] = gl.getUniformLocation(program, info.name);
        }
        uniformsRef.current = uniforms;

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, "a_position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const resize = () => {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = window.innerWidth * dpr;
          canvas.height = window.innerHeight * dpr;
          gl.viewport(0, 0, canvas.width, canvas.height);
          gl.uniform1f(uniforms.u_ratio, canvas.width / canvas.height);
        };

        resize();
        window.addEventListener("resize", resize);

        const render = () => {
          const gl = glRef.current;
          const uniforms = uniformsRef.current;
          if (!gl || !uniforms) return;

          const t = performance.now();

          if (mouseTrackingRef.current) {
            pointerRef.current.x += (pointerRef.current.tX - pointerRef.current.x) * 0.2;
            pointerRef.current.y += (pointerRef.current.tY - pointerRef.current.y) * 0.2;
          } else {
            pointerRef.current.x += (window.innerWidth / 2 - pointerRef.current.x) * 0.05;
            pointerRef.current.y += (window.innerHeight / 2 - pointerRef.current.y) * 0.05;
          }

          const rgb = hexToRgb(colorRef.current);
          gl.uniform3f(uniforms.u_base_color, rgb[0], rgb[1], rgb[2]);
          gl.uniform1f(uniforms.u_time, t);
          gl.uniform2f(
            uniforms.u_pointer_position,
            pointerRef.current.x / window.innerWidth,
            1 - pointerRef.current.y / window.innerHeight
          );
          gl.uniform1f(uniforms.u_scroll_progress, window.pageYOffset / (2 * window.innerHeight));

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          rafRef.current = requestAnimationFrame(render);
        };

        const handleMove = (e) => {
          pointerRef.current.tX = e.clientX || (e.touches && e.touches[0].clientX) || 0;
          pointerRef.current.tY = e.clientY || (e.touches && e.touches[0].clientY) || 0;
        };

        window.addEventListener("pointermove", handleMove, { passive: true });
        window.addEventListener("touchmove", handleMove, { passive: true });

        const onLost = (ev) => {
          ev.preventDefault();
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
        };
        const onRestored = () => {
          cleanup();
          initGL();
        };
        canvas.addEventListener("webglcontextlost", onLost, false);
        canvas.addEventListener("webglcontextrestored", onRestored, false);

        render();

        const cleanup = () => {
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
          window.removeEventListener("resize", resize);
          window.removeEventListener("pointermove", handleMove);
          window.removeEventListener("touchmove", handleMove);
          canvas.removeEventListener("webglcontextlost", onLost);
          canvas.removeEventListener("webglcontextrestored", onRestored);
        };

        return cleanup;
      };

      useEffect(() => {
        let cleanup = null;
        cleanup = initGL();
        return () => { if (cleanup) cleanup(); };
      }, []);

      return (
        <canvas
          ref={canvasRef}
          className="absolute top-0 left-0 w-full h-full pointer-events-none opacity-95 z-0"
          style={{ backgroundColor: "#000" }}
        />
      );
    };

    /*************************
     * ✅ ErrorBoundary: plus jamais d'écran noir silencieux
     *************************/
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }
      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }
      componentDidCatch(error, info) {
        console.error("UI Crash:", error, info);
      }
      render() {
        if (this.state.hasError) {
          return (
            <div className="h-full w-full flex items-center justify-center text-white p-6">
              <div className="max-w-lg w-full bg-black/60 border border-white/10 rounded-3xl p-6">
                <div className="flex items-center gap-2 mb-3">
                  <Icon name="alert-triangle" size={16} />
                  <div className="font-bold">Une erreur est survenue</div>
                </div>
                <div className="text-sm opacity-70 break-words">
                  {String(this.state.error?.message || this.state.error || "Erreur inconnue")}
                </div>
                <button
                  className="mt-4 px-4 py-2 rounded-xl bg-white text-black font-medium"
                  onClick={() => location.reload()}
                >
                  Recharger
                </button>
              </div>
            </div>
          );
        }
        return this.props.children;
      }
    }

    /*************************
     * APP
     *************************/
    const App = () => {
      const isDesktop = useIsDesktop();

      const getInitialSidebarOpen = () =>
        (typeof window !== "undefined" ? window.innerWidth >= 768 : true);

      const [sessions, setSessions] = useState([{ id: 1, title: "Nouvelle conversation", messages: [] }]);
      const [activeSessionId, setActiveSessionId] = useState(1);

      const [isSidebarOpen, setIsSidebarOpen] = useState(getInitialSidebarOpen);

      const [inputText, setInputText] = useState("");
      const [chatPendingCount, setChatPendingCount] = useState(0);
      const isChatLoading = chatPendingCount > 0;

      const [thoughtStepIndex, setThoughtStepIndex] = useState(0);
      const [isRecording, setIsRecording] = useState(false);
      const [showAttachmentMenu, setShowAttachmentMenu] = useState(false);

      const [isConfigOpen, setIsConfigOpen] = useState(false);
      const [config] = useState(DEFAULT_CONFIG);
      const [glowColor, setGlowColor] = useState("#6366f1");
      const [enableMouseTracking, setEnableMouseTracking] = useState(true);

      // ✅ Empêche overlay mobile de "bloquer" l'UI pendant le file picker
      const [isPickingFile, setIsPickingFile] = useState(false);
      useEffect(() => {
        const onFocusBack = () => setIsPickingFile(false);
        window.addEventListener("focus", onFocusBack);
        return () => window.removeEventListener("focus", onFocusBack);
      }, []);

      const [sidebarUpload, setSidebarUpload] = useState({
        status: "idle",
        fileName: "",
        message: "",
      });

      const chatFileInputRef = useRef(null);
      const cameraInputRef = useRef(null);
      const sidebarFileInputRef = useRef(null);

      const messagesEndRef = useRef(null);
      const recognitionRef = useRef(null);

      const objectUrlsRef = useRef(new Set());

      const activeSession = useMemo(
        () => sessions.find((s) => s.id === activeSessionId) || sessions[0],
        [sessions, activeSessionId]
      );

      const isHome = activeSession.messages.length === 0;

      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
      }, [activeSession.messages, isChatLoading]);

      useEffect(() => {
        let interval;
        if (isChatLoading) {
          setThoughtStepIndex(0);
          interval = setInterval(() => {
            setThoughtStepIndex((prev) => (prev < THOUGHT_STEPS.length - 1 ? prev + 1 : prev));
          }, 4000);
        }
        return () => clearInterval(interval);
      }, [isChatLoading]);

      useEffect(() => {
        const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRec) return;
        recognitionRef.current = new SpeechRec();
        recognitionRef.current.lang = "fr-FR";
        recognitionRef.current.onresult = (e) => setInputText((prev) => prev + e.results[0][0].transcript);
        recognitionRef.current.onend = () => setIsRecording(false);
      }, []);

      useEffect(() => {
        return () => {
          for (const url of objectUrlsRef.current) URL.revokeObjectURL(url);
          objectUrlsRef.current.clear();
        };
      }, []);

      const updateSession = (sessionId, updater) => {
        setSessions((prev) => prev.map((s) => (s.id === sessionId ? updater(s) : s)));
      };

      const appendMessage = (sessionId, message) => {
        updateSession(sessionId, (s) => ({ ...s, messages: [...s.messages, message] }));
      };

      const patchMessage = (sessionId, messageId, patch) => {
        updateSession(sessionId, (s) => ({
          ...s,
          messages: s.messages.map((m) => (m.id === messageId ? { ...m, ...patch } : m)),
        }));
      };

      const beginChatRequest = () => setChatPendingCount((n) => n + 1);
      const endChatRequest = () => setChatPendingCount((n) => Math.max(0, n - 1));

      const handleSendMessage = async () => {
        if (!inputText.trim()) return;

        const sessionId = activeSessionId;
        const currentText = inputText.trim();
        const userMsg = { id: uid(), role: "user", type: "text", content: currentText };

        updateSession(sessionId, (s) => ({
          ...s,
          title: s.messages.length === 0 ? currentText.slice(0, 30) : s.title,
          messages: [...s.messages, userMsg],
        }));

        setInputText("");
        beginChatRequest();

        const chatHistory = [...activeSession.messages, userMsg];

        try {
          const { ok, status, data } = await fetchWebhook(N8N_TEXT_WEBHOOK, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message: currentText, sessionId, chatHistory }),
          });

          if (!ok) throw new Error(`Webhook text refusé (${status})`);

          const botResponse = normalizeWebhookResponseToText(data);
          appendMessage(sessionId, { id: uid(), role: "assistant", type: "text", content: botResponse });
        } catch (e) {
          appendMessage(sessionId, {
            id: uid(),
            role: "assistant",
            type: "text",
            content: "Erreur lors de la communication avec le serveur (Webhook).",
            isError: true,
          });
        } finally {
          endChatRequest();
        }
      };

      const handleChatFileUpload = async (files) => {
        if (!files || !files.length) return;

        const sessionId = activeSessionId;
        const file = files[0];

        setShowAttachmentMenu(false);

        // ✅ createObjectURL safe
        let previewUrl = "";
        try {
          if ((file.type || "").startsWith("image/")) {
            previewUrl = URL.createObjectURL(file);
            objectUrlsRef.current.add(previewUrl);
          }
        } catch (_) {
          previewUrl = "";
        }

        const fileMsgId = uid();
        const fileMsg = {
          id: fileMsgId,
          role: "user",
          type: "file",
          fileName: file.name,
          mimeType: file.type || "",
          previewUrl,
          status: "uploading",
        };

        appendMessage(sessionId, fileMsg);
        beginChatRequest();

        const chatHistory = [...activeSession.messages, fileMsg];

        try {
          const serverText = await sendFileToWebhook({
            file,
            sessionId,
            source: "chat",
            chatHistory
          });

          patchMessage(sessionId, fileMsgId, { status: "sent" });

          if (serverText && String(serverText).trim()) {
            appendMessage(sessionId, { id: uid(), role: "assistant", type: "text", content: serverText });
          }
        } catch (e) {
          patchMessage(sessionId, fileMsgId, { status: "error", error: e?.message || "Erreur lors de l'upload." });
        } finally {
          endChatRequest();
        }

        if (chatFileInputRef.current) chatFileInputRef.current.value = "";
        if (cameraInputRef.current) cameraInputRef.current.value = "";
      };

      const handleSidebarFileUpload = async (files) => {
        if (!files || !files.length) return;

        const file = files[0];
        const sessionId = activeSessionId;

        setSidebarUpload({ status: "uploading", fileName: file.name, message: "Chargement en cours…" });

        try {
          const serverText = await sendFileToWebhook({
            file,
            sessionId,
            source: "sidebar",
            chatHistory: null
          });

          setSidebarUpload({
            status: "success",
            fileName: file.name,
            message: serverText || "Document importé avec succès.",
          });
        } catch (e) {
          setSidebarUpload({
            status: "error",
            fileName: file.name,
            message: e?.message || "Erreur lors de l'import.",
          });
        } finally {
          if (sidebarFileInputRef.current) sidebarFileInputRef.current.value = "";
        }
      };

      const createNewChat = () => {
        const id = Date.now();
        setSessions((prev) => [{ id, title: "Nouveau chat", messages: [] }, ...prev]);
        setActiveSessionId(id);
        if (!isDesktop) setIsSidebarOpen(false);
      };

      const sidebarDrawerClasses = `
        fixed md:relative inset-y-0 left-0
        w-72
        ${isSidebarOpen ? "translate-x-0 md:w-72" : "-translate-x-full md:w-0"}
        md:translate-x-0
        transition-all duration-300
        bg-black/60 backdrop-blur-xl border-r border-white/10
        flex flex-col z-40 overflow-hidden
      `;

      return (
        <div className="flex h-full relative text-white overflow-hidden bg-black">
          <NeuralGlow color={glowColor} mouseTracking={enableMouseTracking} />

          {/* ✅ Overlay mobile pour fermer la sidebar (désactivé pendant file picker) */}
          {!isDesktop && isSidebarOpen && !isPickingFile && (
            <div
              className="fixed inset-0 bg-black/60 z-30"
              onClick={() => setIsSidebarOpen(false)}
            />
          )}

          {/* SIDEBAR */}
          <aside className={sidebarDrawerClasses}>
            <div className="w-72 flex flex-col h-full">
              <div className="p-4 space-y-4">
                <div className="flex justify-between items-center">
                  <span className="font-bold text-lg px-2 opacity-80">Menu</span>
                  <button
                    onClick={() => setIsSidebarOpen(false)}
                    className="p-2 hover:bg-white/10 rounded-lg transition-colors"
                  >
                    <Icon name="panel-left-close" />
                  </button>
                </div>

                <div className="space-y-2">
                  <button
                    onClick={createNewChat}
                    className="w-full flex items-center gap-3 bg-indigo-600 hover:bg-indigo-500 p-3 rounded-xl transition-all shadow-lg font-medium"
                  >
                    <Icon name="plus" size={18} /> Nouveau chat
                  </button>

                  <button
                    onClick={() => {
                      setIsPickingFile(true);
                      sidebarFileInputRef.current?.click();
                    }}
                    className="w-full flex items-center gap-3 bg-white/5 hover:bg-white/10 border border-white/10 p-3 rounded-xl transition-all font-medium text-white/80"
                  >
                    <Icon name="upload-cloud" size={18} /> Charger un document
                  </button>

                  {sidebarUpload.status !== "idle" && (
                    <div className="mt-3 p-3 rounded-2xl bg-white/5 border border-white/10">
                      <div className="flex items-start gap-3">
                        <div className="mt-0.5">
                          {sidebarUpload.status === "uploading" && (
                            <Icon name="loader-2" size={16} className="animate-spin opacity-80" />
                          )}
                          {sidebarUpload.status === "success" && (
                            <Icon name="check-circle-2" size={16} className="opacity-80" />
                          )}
                          {sidebarUpload.status === "error" && (
                            <Icon name="x-circle" size={16} className="opacity-80" />
                          )}
                        </div>

                        <div className="min-w-0 flex-1">
                          <div className="text-sm font-medium truncate">
                            {sidebarUpload.fileName || "Document"}
                          </div>
                          <div className="text-xs opacity-60 mt-1 break-words">
                            {sidebarUpload.message}
                          </div>
                          <div className="mt-2 flex gap-2">
                            <button
                              onClick={() => setSidebarUpload({ status: "idle", fileName: "", message: "" })}
                              className="text-xs px-3 py-1 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10"
                            >
                              Fermer
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              </div>

              <div className="flex-1 overflow-y-auto px-2 space-y-1 custom-scrollbar">
                <div className="px-2 pb-2 text-[10px] uppercase tracking-widest font-bold opacity-30 mt-4">
                  Historique
                </div>
                {sessions.map((s) => (
                  <div
                    key={s.id}
                    onClick={() => {
                      setActiveSessionId(s.id);
                      if (!isDesktop) setIsSidebarOpen(false);
                    }}
                    className={`p-3 rounded-xl text-sm cursor-pointer truncate flex items-center gap-3 transition-all ${
                      activeSessionId === s.id
                        ? "bg-white/10 text-white border border-white/5"
                        : "hover:bg-white/5 text-white/50 border border-transparent"
                    }`}
                  >
                    <Icon name="message-square" size={14} /> {s.title}
                  </div>
                ))}
              </div>

              <div className="p-4 border-t border-white/5">
                <button
                  onClick={() => setIsConfigOpen(true)}
                  className="flex items-center gap-2 w-full p-2 hover:bg-white/5 rounded-lg text-sm opacity-60 hover:opacity-100 transition-opacity"
                >
                  <Icon name="settings" size={16} /> Paramètres
                </button>
              </div>
            </div>
          </aside>

          {/* MAIN */}
          <main className="flex-1 flex flex-col relative z-10 h-full">
            <header className="absolute top-0 w-full p-4 flex items-center gap-4 z-30 pointer-events-none">
              {!isSidebarOpen && (
                <button
                  onClick={() => setIsSidebarOpen(true)}
                  className="p-2 bg-black/40 rounded-lg backdrop-blur-md border border-white/10 pointer-events-auto"
                >
                  <Icon name="panel-left" />
                </button>
              )}
              <h1 className="font-bold text-xl drop-shadow-md opacity-80 pointer-events-none">
                {config.companyName}
              </h1>
            </header>

            <div className="flex-1 overflow-y-auto custom-scrollbar p-4 relative">
              {isHome ? (
                <div className="h-full flex flex-col items-center justify-center text-center animate-fadeIn px-6">
                  <div className="p-6 rounded-full bg-black/40 border border-white/10 backdrop-blur-2xl mb-8 shadow-2xl relative">
                    <Icon name="sparkles" size={48} className="text-indigo-400" />
                    <div className="absolute inset-0 bg-indigo-500/20 blur-2xl rounded-full -z-10 animate-pulse"></div>
                  </div>
                  <h2 className="text-4xl md:text-5xl font-bold mb-4">Comment puis-je</h2>
                  <h2 className="text-4xl md:text-5xl font-black text-indigo-400 mb-4">vous aider ?</h2>
                  <p className="text-white/40 max-w-md">
                    Posez-moi une question ou téléchargez un document pour commencer notre échange.
                  </p>
                </div>
              ) : (
                <div className="max-w-3xl mx-auto py-20 space-y-6">
                  {activeSession.messages.map((m) => (
                    <div
                      key={m.id}
                      className={`flex gap-4 animate-fadeIn ${m.role === "user" ? "flex-row-reverse" : ""}`}
                    >
                      <div
                        className={`w-10 h-10 rounded-full flex items-center justify-center shrink-0 shadow-lg ${
                          m.role === "user"
                            ? "bg-indigo-600"
                            : "bg-black/80 border border-white/10"
                        }`}
                      >
                        <Icon name={m.role === "user" ? "user" : "bot"} size={18} />
                      </div>

                      <div
                        className={`p-5 rounded-2xl max-w-[85%] backdrop-blur-xl border border-white/10 shadow-xl ${
                          m.role === "user" ? "bg-indigo-600/40 text-white/90" : "bg-black/60"
                        }`}
                      >
                        {m.type === "file" ? <FileBubble m={m} /> : <MessageContent content={m.content} />}
                      </div>
                    </div>
                  ))}

                  {isChatLoading && (
                    <div className="flex gap-4 animate-fadeIn">
                      <div className="w-10 h-10 rounded-full flex items-center justify-center shrink-0 bg-black/60 border border-white/10">
                        <Icon name="bot" size={18} className="animate-pulse" />
                      </div>
                      <div className="flex flex-col gap-2 py-2">
                        <div className="flex items-center gap-3 text-white/40 text-sm animate-pulse-soft">
                          <Icon name="loader-2" size={14} className="animate-spin text-indigo-400" />
                          <span className="transition-all duration-1000">{THOUGHT_STEPS[thoughtStepIndex]}…</span>
                        </div>
                      </div>
                    </div>
                  )}

                  <div ref={messagesEndRef} />
                </div>
              )}
            </div>

            {/* INPUT BAR */}
            <div className="p-4 pb-10 relative z-30">
              <div className="max-w-3xl mx-auto">
                <div className="bg-black/60 backdrop-blur-3xl border border-white/10 p-2 rounded-[32px] flex items-end gap-2 shadow-2xl transition-all focus-within:border-indigo-500/50">
                  <div className="relative">
                    <button
                      onClick={() => setShowAttachmentMenu(!showAttachmentMenu)}
                      className={`p-3 rounded-full transition-colors ${
                        showAttachmentMenu ? "bg-white/10 text-white" : "text-white/40 hover:text-white"
                      }`}
                    >
                      <Icon name="paperclip" />
                    </button>

                    {showAttachmentMenu && (
                      <div className="absolute bottom-full left-0 mb-4 bg-[#121212] border border-white/10 rounded-2xl p-2 w-52 shadow-2xl animate-fadeIn">
                        <button
                          onClick={() => {
                            setIsPickingFile(true);
                            cameraInputRef.current?.click();
                          }}
                          className="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl text-sm transition-colors text-left"
                        >
                          <Icon name="camera" size={16} className="text-indigo-400" /> Prendre une photo
                        </button>
                        <button
                          onClick={() => {
                            setIsPickingFile(true);
                            chatFileInputRef.current?.click();
                          }}
                          className="w-full flex items-center gap-3 p-3 hover:bg-white/5 rounded-xl text-sm transition-colors text-left"
                        >
                          <Icon name="image" size={16} className="text-purple-400" /> Charger un document
                        </button>
                      </div>
                    )}
                  </div>

                  <textarea
                    className="flex-1 bg-transparent border-none outline-none py-3 px-2 text-white placeholder-white/20 resize-none max-h-32 custom-scrollbar"
                    placeholder="Posez votre question..."
                    rows={1}
                    value={inputText}
                    onChange={(e) => setInputText(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter" && !e.shiftKey) {
                        e.preventDefault();
                        handleSendMessage();
                      }
                    }}
                  />

                  <button
                    onClick={() => {
                      if (!isRecording) {
                        recognitionRef.current?.start();
                        setIsRecording(true);
                      } else {
                        recognitionRef.current?.stop();
                      }
                    }}
                    className={`p-3 rounded-full transition-colors ${
                      isRecording
                        ? "text-red-500 animate-pulse bg-red-500/10"
                        : "text-white/40 hover:text-white"
                    }`}
                  >
                    <Icon name="mic" />
                  </button>

                  <button
                    onClick={handleSendMessage}
                    className={`h-10 w-10 rounded-full flex items-center justify-center transition-all shrink-0 ${
                      inputText.trim()
                        ? "bg-white text-black hover:scale-105"
                        : "bg-white/10 text-white/20 cursor-not-allowed"
                    }`}
                  >
                    <Icon name="arrow-up" size={20} />
                  </button>
                </div>
              </div>
            </div>

            {/* INPUTS */}
            <input
              type="file"
              ref={chatFileInputRef}
              className="hidden"
              accept="image/*,application/pdf,.doc,.docx,.txt"
              onChange={(e) => handleChatFileUpload(e.target.files)}
            />
            <input
              type="file"
              ref={cameraInputRef}
              className="hidden"
              accept="image/*"
              capture="environment"
              onChange={(e) => handleChatFileUpload(e.target.files)}
            />
            <input
              type="file"
              ref={sidebarFileInputRef}
              className="hidden"
              accept="image/*,application/pdf,.doc,.docx,.txt"
              onChange={(e) => handleSidebarFileUpload(e.target.files)}
            />
          </main>

          {/* CONFIG MODAL */}
          {isConfigOpen && (
            <div
              className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm px-4"
              onClick={() => setIsConfigOpen(false)}
            >
              <div
                className="bg-[#121212] border border-white/10 p-6 rounded-3xl w-full max-w-sm shadow-2xl"
                onClick={(e) => e.stopPropagation()}
              >
                <div className="flex justify-between items-center mb-6">
                  <h3 className="text-lg font-bold">Personnalisation</h3>
                  <button onClick={() => setIsConfigOpen(false)} className="p-1 hover:bg-white/10 rounded-full">
                    <Icon name="x" size={16} />
                  </button>
                </div>

                <div className="space-y-6">
                  <div>
                    <label className="block text-[10px] font-bold uppercase tracking-widest opacity-40 mb-3">
                      Couleur Thématique
                    </label>
                    <div className="flex items-center gap-4 p-3 bg-white/5 rounded-2xl border border-white/5">
                      <input
                        type="color"
                        value={glowColor}
                        onChange={(e) => setGlowColor(e.target.value)}
                        className="w-10 h-10 rounded-xl bg-transparent border-none cursor-pointer overflow-hidden"
                      />
                      <span className="font-mono text-sm opacity-60 uppercase">{glowColor}</span>
                    </div>
                  </div>

                  <div className="flex justify-between items-center p-3 bg-white/5 rounded-2xl border border-white/5">
                    <div className="flex flex-col">
                      <span className="text-sm font-medium">Interaction Dynamique</span>
                      <span className="text-[10px] opacity-40 uppercase">Suivi de la souris</span>
                    </div>
                    <button
                      onClick={() => setEnableMouseTracking(!enableMouseTracking)}
                      className={`w-12 h-6 rounded-full relative transition-colors ${
                        enableMouseTracking ? "bg-indigo-600" : "bg-white/10"
                      }`}
                    >
                      <div
                        className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-all shadow-md ${
                          enableMouseTracking ? "right-1" : "left-1"
                        }`}
                      />
                    </button>
                  </div>
                </div>

                <button
                  onClick={() => setIsConfigOpen(false)}
                  className="w-full mt-8 py-4 bg-white text-black rounded-2xl font-black text-sm uppercase tracking-widest hover:bg-gray-200 transition-colors"
                >
                  Terminer
                </button>
              </div>
            </div>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(
      <ErrorBoundary>
        <App />
      </ErrorBoundary>
    );
  </script>
</body>
</html>
