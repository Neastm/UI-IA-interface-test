import React, { useState, useEffect, useRef, useCallback } from 'react';
import {
  Send,
  Mic,
  Paperclip,
  Bot,
  User,
  Settings,
  X,
  FileText,
  Loader2,
  Moon,
  Sun,
  Volume2,
  VolumeX,
  Sparkles,
  ArrowRight,
  Menu,
  Plus,
  MessageSquare,
  PanelLeftClose,
  PanelLeft,
  MoreHorizontal,
  Trash2,
  Code,
  PenTool,
  Lightbulb,
  FileUp,
  AlertCircle
} from 'lucide-react';

// --- CONFIGURATION EXTERNE ---
// REMPLACEZ CETTE URL PAR VOTRE WEBHOOK N8N
const N8N_WEBHOOK_URL = ""; 

const DEFAULT_CONFIG = {
  companyName: "Nexus AI",
  agentName: "Nexus Agent",
  primaryColor: "#6366f1",
  secondaryColor: "#4f46e5",
  logoUrl: "", 
  welcomeMessage: "Bonjour ! Je suis l'IA de Nexus. Comment puis-je vous aider aujourd'hui ?"
};

// --- COMPOSANT NEURAL GLOW ---
const NeuralGlow = () => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const glRef = useRef(null);
  const uniformsRef = useRef(null);
  const pointerRef = useRef({ x: 0, y: 0, tX: 0, tY: 0 });

  const vertexShaderSource = `
    precision mediump float;
    varying vec2 vUv;
    attribute vec2 a_position;
    void main() {
        vUv = .5 * (a_position + 1.);
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  const fragmentShaderSource = `
    precision mediump float;
    varying vec2 vUv;
    uniform float u_time;
    uniform float u_ratio;
    uniform vec2 u_pointer_position;
    uniform float u_scroll_progress;

    vec2 rotate(vec2 uv, float th) {
        return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
    }

    float neuro_shape(vec2 uv, float t, float p) {
        vec2 sine_acc = vec2(0.);
        vec2 res = vec2(0.);
        float scale = 8.;
        for (int j = 0; j < 15; j++) {
            uv = rotate(uv, 1.);
            sine_acc = rotate(sine_acc, 1.);
            vec2 layer = uv * scale + float(j) + sine_acc - t;
            sine_acc += sin(layer) + 2.4 * p;
            res += (.5 + .5 * cos(layer)) / scale;
            scale *= (1.2);
        }
        return res.x + res.y;
    }

    void main() {
        vec2 uv = .5 * vUv;
        uv.x *= u_ratio;
        vec2 pointer = vUv - u_pointer_position;
        pointer.x *= u_ratio;
        float p = clamp(length(pointer), 0., 1.);
        p = .5 * pow(1. - p, 2.);
        float t = .001 * u_time;
        vec3 color = vec3(0.1, 0.2, 0.8); 
        color += vec3(0.0, 0.1, 0.4) * sin(3.0 * u_scroll_progress + 1.5);
        float noise = neuro_shape(uv, t, p);
        noise = 1.2 * pow(noise, 3.);
        noise += pow(noise, 10.);
        noise = max(.0, noise - .5);
        noise *= (1. - length(vUv - .5));
        color = color * noise;
        gl_FragColor = vec4(color, noise);
    }
  `;

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const gl = canvas.getContext('webgl');
    if (!gl) return;
    glRef.current = gl;

    const compileShader = (source, type) => {
      const s = gl.createShader(type);
      gl.shaderSource(s, source);
      gl.compileShader(s);
      return s;
    };

    const vs = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    const fs = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);

    const uniforms = {
      u_time: gl.getUniformLocation(program, 'u_time'),
      u_ratio: gl.getUniformLocation(program, 'u_ratio'),
      u_pointer_position: gl.getUniformLocation(program, 'u_pointer_position'),
      u_scroll_progress: gl.getUniformLocation(program, 'u_scroll_progress'),
    };
    uniformsRef.current = uniforms;

    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const pos = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(pos);
    gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

    const resize = () => {
      canvas.width = window.innerWidth * window.devicePixelRatio;
      canvas.height = window.innerHeight * window.devicePixelRatio;
      gl.uniform1f(uniformsRef.current.u_ratio, canvas.width / canvas.height);
      gl.viewport(0, 0, canvas.width, canvas.height);
    };

    const loop = () => {
      const t = performance.now();
      pointerRef.current.x += (pointerRef.current.tX - pointerRef.current.x) * 0.15;
      pointerRef.current.y += (pointerRef.current.tY - pointerRef.current.y) * 0.15;
      gl.uniform1f(uniforms.u_time, t);
      gl.uniform2f(uniforms.u_pointer_position, pointerRef.current.x / window.innerWidth, 1 - pointerRef.current.y / window.innerHeight);
      gl.uniform1f(uniforms.u_scroll_progress, window.pageYOffset / window.innerHeight);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      animationRef.current = requestAnimationFrame(loop);
    };

    window.addEventListener('resize', resize);
    window.addEventListener('pointermove', (e) => {
      pointerRef.current.tX = e.clientX;
      pointerRef.current.tY = e.clientY;
    });
    resize();
    loop();
    return () => {
      cancelAnimationFrame(animationRef.current);
      window.removeEventListener('resize', resize);
    };
  }, []);

  return <canvas ref={canvasRef} className="absolute inset-0 w-full h-full pointer-events-none z-0" style={{ backgroundColor: '#000' }} />;
};

// --- SIDEBAR ---
const Sidebar = ({ isOpen, setIsOpen, sessions, activeSessionId, onNewChat, onSelectSession, onDeleteSession, isDarkMode, setIsConfigOpen }) => {
  return (
    <aside 
      className={`relative flex flex-col border-r transition-all duration-500 ease-[cubic-bezier(0.4,0,0.2,1)] overflow-hidden h-full z-40 ${
        isDarkMode ? 'bg-[#0a0a0a] border-gray-800 text-gray-100' : 'bg-gray-50 border-gray-200 text-gray-800'
      }`}
      style={{ width: isOpen ? '280px' : '0px', opacity: isOpen ? 1 : 0 }}
    >
      <div className="w-[280px] flex flex-col h-full flex-shrink-0">
        <div className="p-4 flex items-center justify-between gap-2">
           <button 
             onClick={onNewChat}
             className={`flex-1 flex items-center gap-2 px-3 py-2.5 rounded-xl text-sm transition-all border ${isDarkMode ? 'bg-gray-900 border-gray-700 hover:bg-gray-800' : 'bg-white border-gray-200 hover:bg-gray-100'}`}
           >
             <Plus size={16} />
             <span className="font-medium">Nouveau chat</span>
           </button>
           <button onClick={() => setIsOpen(false)} className={`p-2 rounded-lg hover:bg-white/10 ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>
              <PanelLeftClose size={20} />
           </button>
        </div>

        <div className="flex-1 overflow-y-auto px-3 space-y-1">
          <p className="px-3 py-2 text-[11px] font-bold tracking-widest uppercase opacity-40">Historique</p>
          {sessions.map(session => (
            <div 
              key={session.id}
              onClick={() => onSelectSession(session.id)}
              className={`group flex items-center gap-3 px-3 py-2.5 rounded-xl text-sm cursor-pointer transition-all ${
                activeSessionId === session.id 
                  ? (isDarkMode ? 'bg-gray-800/80 shadow-sm' : 'bg-gray-200') 
                  : (isDarkMode ? 'hover:bg-gray-900' : 'hover:bg-gray-100')
              }`}
            >
              <MessageSquare size={16} className="opacity-50 flex-shrink-0" />
              <span className="truncate flex-1 font-medium">{session.title}</span>
              <button onClick={(e) => { e.stopPropagation(); onDeleteSession(session.id); }} className="opacity-0 group-hover:opacity-100 p-1 hover:text-red-400"><Trash2 size={14} /></button>
            </div>
          ))}
        </div>

        <div className="p-4 border-t border-white/5">
           <button onClick={() => setIsConfigOpen(true)} className={`w-full flex items-center gap-3 px-3 py-3 rounded-xl text-sm transition-all ${isDarkMode ? 'hover:bg-gray-800' : 'hover:bg-gray-100'}`}>
              <Settings size={18} className="opacity-60" />
              <span>Paramètres</span>
           </button>
        </div>
      </div>
    </aside>
  );
};

// --- INPUT BAR ---
const InputBar = ({ inputText, setInputText, handleSendMessage, isDarkMode, primaryColor, isHome = false, isLoading }) => {
  const [isRecording, setIsRecording] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [attachedFiles, setAttachedFiles] = useState([]);
  const areaRef = useRef(null);
  const fileInputRef = useRef(null);
  const recognitionRef = useRef(null);

  useEffect(() => {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
      recognitionRef.current = new SpeechRecognition();
      recognitionRef.current.continuous = true;
      recognitionRef.current.interimResults = true;
      recognitionRef.current.lang = 'fr-FR';

      recognitionRef.current.onresult = (event) => {
        let finalTranscript = '';
        for (let i = event.resultIndex; i < event.results.length; ++i) {
          if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;
        }
        if (finalTranscript) setInputText(prev => (prev ? prev + ' ' : '') + finalTranscript);
      };
      recognitionRef.current.onend = () => setIsRecording(false);
      recognitionRef.current.onerror = () => setIsRecording(false);
    }
  }, [setInputText]);

  const toggleRecording = async () => {
    if (!recognitionRef.current) return;
    if (isRecording) {
      recognitionRef.current.stop();
    } else {
      try {
        await navigator.mediaDevices.getUserMedia({ audio: true });
        recognitionRef.current.start();
        setIsRecording(true);
      } catch (err) {
        console.error("Microphone inaccessible");
      }
    }
  };

  const handleFileAttach = (files) => {
    const newFiles = Array.from(files).map(f => ({
      name: f.name,
      size: f.size,
      type: f.type,
      id: Math.random().toString(36).substr(2, 9),
      rawFile: f // On garde le fichier brut pour l'envoi éventuel
    }));
    setAttachedFiles(prev => [...prev, ...newFiles]);
  };

  const onSend = () => {
    handleSendMessage(inputText, attachedFiles);
    setAttachedFiles([]);
  };

  useEffect(() => {
    if(areaRef.current) {
        areaRef.current.style.height = 'auto';
        areaRef.current.style.height = areaRef.current.scrollHeight + 'px';
    }
  }, [inputText]);

  return (
    <div 
      className={`w-full transition-all duration-500 mx-auto relative ${isHome ? 'max-w-xl' : 'max-w-3xl'}`}
      onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
      onDragLeave={() => setIsDragging(false)}
      onDrop={(e) => { e.preventDefault(); setIsDragging(false); if (e.dataTransfer.files.length) handleFileAttach(e.dataTransfer.files); }}
    >
      {isDragging && (
        <div className="absolute inset-0 z-50 rounded-[28px] bg-indigo-500/10 border-2 border-dashed border-indigo-500 flex items-center justify-center backdrop-blur-sm animate-pulse pointer-events-none">
          <div className="flex flex-col items-center gap-2 text-indigo-500">
            <FileUp size={48} />
            <span className="font-bold">Déposez vos fichiers</span>
          </div>
        </div>
      )}

      {attachedFiles.length > 0 && (
        <div className="flex flex-wrap gap-2 mb-3 animate-fadeIn px-2">
          {attachedFiles.map(file => (
            <div key={file.id} className={`flex items-center gap-2 px-3 py-1.5 rounded-xl text-xs border ${isDarkMode ? 'bg-gray-800 border-gray-700 text-gray-300' : 'bg-gray-100 border-gray-200 text-gray-700'}`}>
              <FileText size={14} className="text-indigo-500" />
              <span className="max-w-[120px] truncate">{file.name}</span>
              <button onClick={() => setAttachedFiles(prev => prev.filter(f => f.id !== file.id))} className="hover:text-red-500"><X size={14}/></button>
            </div>
          ))}
        </div>
      )}

      <div className={`relative flex items-end gap-2 p-2 rounded-[28px] border transition-all shadow-lg ${
        isHome 
          ? 'bg-white/10 backdrop-blur-2xl border-white/20 p-3 ring-1 ring-white/10 shadow-indigo-500/10' 
          : (isDarkMode ? 'bg-[#2f2f2f] border-gray-700 focus-within:border-gray-500' : 'bg-[#f4f4f4] border-gray-200 focus-within:border-gray-300 focus-within:bg-white')
      }`}>
        <button 
          onClick={() => fileInputRef.current.click()}
          className={`p-3 mb-1 rounded-full transition-all ${isHome ? 'text-white/60 hover:text-white hover:bg-white/10' : 'text-gray-400 hover:bg-gray-700'}`}
        >
          <Plus size={20} />
        </button>
        <input type="file" multiple ref={fileInputRef} className="hidden" onChange={(e) => handleFileAttach(e.target.files)} />

        <textarea
            ref={areaRef}
            rows={1}
            value={inputText}
            onChange={(e) => setInputText(e.target.value)}
            onKeyDown={(e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); onSend(); } }}
            placeholder={isHome ? "Une question ?" : "Message..."}
            className={`flex-1 bg-transparent outline-none py-3 px-1 max-h-[200px] resize-none ${isHome ? 'text-white placeholder-white/40 text-lg' : (isDarkMode ? 'text-white' : 'text-gray-800')}`}
        />

        <button onClick={toggleRecording} className={`p-3 mb-1 rounded-full transition-all ${isRecording ? 'bg-red-500 text-white' : (isHome ? 'text-white/60 hover:bg-white/10' : 'text-gray-400 hover:bg-gray-700')}`}>
            <Mic size={20} className={isRecording ? 'animate-pulse' : ''} />
        </button>

        <button 
          onClick={onSend}
          disabled={(!inputText.trim() && attachedFiles.length === 0) || isLoading}
          className={`p-3 mb-1 rounded-2xl transition-all flex items-center justify-center`}
          style={{ backgroundColor: isHome ? 'white' : primaryColor, color: isHome ? 'black' : 'white', opacity: isLoading ? 0.5 : 1 }}
        >
          {isLoading ? <Loader2 size={20} className="animate-spin" /> : <ArrowRight size={20} />}
        </button>
      </div>
    </div>
  );
};

// --- MAIN APP ---
export default function App() {
  const [sessions, setSessions] = useState([{ id: 1, title: 'Nouvelle conversation', messages: [] }]);
  const [activeSessionId, setActiveSessionId] = useState(1);
  const [isSidebarOpen, setIsSidebarOpen] = useState(true);
  const [inputText, setInputText] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isDarkMode, setIsDarkMode] = useState(true);
  const [isConfigOpen, setIsConfigOpen] = useState(false);
  const [config, setConfig] = useState(DEFAULT_CONFIG);

  const activeSession = sessions.find(s => s.id === activeSessionId) || sessions[0];
  const isHome = activeSession.messages.length === 0;

  // --- FONCTION APPEL WEBHOOK N8N ---
  const callN8NWebhook = async (text, files) => {
    if (!N8N_WEBHOOK_URL) {
      return { error: "L'URL du Webhook n8n n'est pas configurée dans le code." };
    }

    try {
      // Préparation du payload
      // On peut envoyer du JSON ou du FormData si on a des fichiers
      let body;
      let headers = {};

      if (files.length > 0) {
        const formData = new FormData();
        formData.append('message', text);
        files.forEach((f, idx) => formData.append(`file_${idx}`, f.rawFile));
        body = formData;
      } else {
        headers['Content-Type'] = 'application/json';
        body = JSON.stringify({ message: text, sessionId: activeSessionId });
      }

      const response = await fetch(N8N_WEBHOOK_URL, {
        method: 'POST',
        headers,
        body
      });

      if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);

      const data = await response.json();
      
      // LOGIQUE DE VALIDATION : On vérifie si n8n a renvoyé quelque chose
      // On s'attend généralement à un objet { output: "..." } ou { message: "..." }
      const output = data.output || data.message || data.text || (Array.isArray(data) ? data[0]?.output : null);

      if (!output || output.toString().trim() === "") {
        return { error: "Le workflow n8n n'a renvoyé aucun contenu. Vérifiez votre nœud 'Respond to Webhook'." };
      }

      return { content: output };
    } catch (err) {
      console.error("Erreur Webhook:", err);
      return { error: "Impossible de contacter le serveur Nexus. Vérifiez votre connexion ou l'état du workflow." };
    }
  };

  const handleSendMessage = async (text, files = []) => {
    const msg = text || inputText;
    if((!msg.trim() && files.length === 0) || isLoading) return;
    
    const userMsg = { 
      id: Date.now(), 
      role: 'user', 
      content: msg,
      files: files.length > 0 ? files : null
    };

    setSessions(prev => prev.map(s => s.id === activeSessionId ? { 
      ...s, 
      messages: [...s.messages, userMsg], 
      title: s.messages.length === 0 ? (msg ? msg.slice(0, 20) : "Analyse de fichier") : s.title 
    } : s));
    
    setInputText('');
    setIsLoading(true);

    // APPEL RÉEL AU WEBHOOK
    const result = await callN8NWebhook(msg, files);

    const assistantMsg = { 
        id: Date.now() + 1, 
        role: 'assistant', 
        content: result.content || result.error,
        isError: !!result.error 
    };

    setSessions(prev => prev.map(s => s.id === activeSessionId ? { 
        ...s, 
        messages: [...s.messages, assistantMsg] 
    } : s));
    
    setIsLoading(false);
  };

  return (
    <div className={`flex h-screen font-sans overflow-hidden transition-colors duration-500 ${isDarkMode ? 'bg-[#121212] text-white' : 'bg-white text-gray-900'}`}>
      
      <Sidebar 
        isOpen={isSidebarOpen} setIsOpen={setIsSidebarOpen} 
        sessions={sessions} activeSessionId={activeSessionId} 
        onNewChat={() => { const id = Date.now(); setSessions([{ id, title: 'Nouveau chat', messages: [] }, ...sessions]); setActiveSessionId(id); }}
        onSelectSession={setActiveSessionId}
        onDeleteSession={(id) => setSessions(prev => prev.filter(s => s.id !== id))}
        isDarkMode={isDarkMode} setIsConfigOpen={setIsConfigOpen}
      />

      <div className="flex-1 flex flex-col relative min-w-0">
        <header className="absolute top-0 left-0 right-0 p-4 z-40 flex items-center justify-between">
           <div className="flex items-center gap-4">
               {!isSidebarOpen && <button onClick={() => setIsSidebarOpen(true)} className="p-2.5 rounded-xl bg-white/5 hover:bg-white/10 backdrop-blur-md transition-all"><PanelLeft size={22} /></button>}
               <h1 className="font-bold text-xl tracking-tight">{config.companyName}</h1>
           </div>
           <button onClick={() => setIsDarkMode(!isDarkMode)} className="p-2.5 rounded-xl hover:bg-white/10 transition-all opacity-70">
                {isDarkMode ? <Sun size={20} /> : <Moon size={20} />}
           </button>
        </header>

        {/* Home Screen */}
        <div className={`absolute inset-0 flex flex-col items-center justify-center p-6 transition-all duration-700 ${isHome ? 'opacity-100 z-10' : 'opacity-0 z-0 pointer-events-none -translate-y-8'}`}>
            <NeuralGlow />
            <div className="relative z-10 w-full flex flex-col items-center gap-10">
                <div className="text-center">
                    <div className="inline-flex p-3 rounded-2xl bg-white/10 backdrop-blur-xl border border-white/20 mb-4"><Sparkles className="text-white animate-pulse" size={32} /></div>
                    <h2 className="text-4xl md:text-6xl font-bold text-white leading-tight">Prêt pour <br/> <span className="text-white/60">votre prochaine idée ?</span></h2>
                </div>
                <InputBar isHome={true} inputText={inputText} setInputText={setInputText} handleSendMessage={handleSendMessage} isDarkMode={isDarkMode} primaryColor={config.primaryColor} isLoading={isLoading} />
            </div>
        </div>

        {/* Chat Flow */}
        <div className={`flex-1 flex flex-col h-full transition-all duration-700 ${!isHome ? 'opacity-100 z-10' : 'opacity-0 z-0'}`}>
            <main className="flex-1 overflow-y-auto pt-24 pb-12 px-4">
                <div className="max-w-3xl mx-auto space-y-10">
                    {activeSession.messages.map(m => (
                        <div key={m.id} className={`flex items-start gap-5 ${m.role === 'user' ? 'flex-row-reverse' : ''} animate-fadeIn`}>
                            <div className={`w-9 h-9 rounded-xl flex items-center justify-center flex-shrink-0 shadow-lg ${m.role === 'user' ? 'bg-gray-600' : (m.isError ? 'bg-red-500' : 'bg-indigo-600')}`}>
                                {m.role === 'user' ? <User size={18}/> : (m.isError ? <AlertCircle size={18}/> : <Bot size={18}/>)}
                            </div>
                            <div className={`max-w-[85%] space-y-3 ${m.role === 'user' ? 'text-right' : ''}`}>
                                <div className={`text-base leading-relaxed p-4 rounded-2xl ${
                                    m.role === 'user' 
                                    ? (isDarkMode ? 'bg-gray-800 text-white' : 'bg-gray-100 text-gray-800 shadow-sm') 
                                    : (m.isError ? 'bg-red-500/10 border border-red-500/20 text-red-400' : (isDarkMode ? 'text-gray-200' : 'text-gray-800'))
                                }`}>
                                    {m.content}
                                </div>
                            </div>
                        </div>
                    ))}
                    {isLoading && <div className="flex gap-2 text-indigo-400 animate-pulse"><Loader2 size={16} className="animate-spin" /> <span className="text-sm">En attente de Nexus...</span></div>}
                </div>
            </main>
            <footer className={`p-6 border-t ${isDarkMode ? 'bg-[#121212] border-white/5' : 'bg-white border-gray-100'}`}>
                <InputBar inputText={inputText} setInputText={setInputText} handleSendMessage={handleSendMessage} isDarkMode={isDarkMode} primaryColor={config.primaryColor} isLoading={isLoading} />
            </footer>
        </div>
      </div>
    </div>
  );
}

const styles = `@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } } .animate-fadeIn { animation: fadeIn 0.4s ease-out forwards; }`;
if(typeof document !== 'undefined'){ const s = document.createElement('style'); s.innerHTML = styles; document.head.appendChild(s); }
